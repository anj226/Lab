# Accumulator

Implement a basic Accumulaotr in RSA groups.

## 00-SetUp

Generate the parameter for RSA groups (the modular $N = p \cdot q$). 

The $N$ should be generated by a trusted third party. In the code, we just sample 2 random primes and get their product.

## 01-Digest

What is Digest?

After we have collecting some contents we can give the digest of these contents. The digest can represent the compostion of those contents. In the following steps we will use Membership or Non-Membership proof to show that a content is in or not in a digest.

How to Digest?

The key point of accumulater is that it wants to have a constant time verifiable (Non)Membership proof. 
Assume that we can hash all of our contents into a different prime number with the function $H(.)$. We can simply hash all of our input to prime numbers and multiply them up and take the product as the digestion $d$. That is, we have $d = \Pi_{s\in S}H(s)$  . To prove that there is a number $x$ in the digestion, ones just have to show that the digestion $d$ can be divided in to $d = x \cdot p$  by given the $p$. The verifier can simply check the result of $x\cdot p==d$  which need only constant time to check the answer.

In this way, the size of digestion get bigger when every time we add a new element. We additionally want to have our digestion in a fixed size. So we want to modular our digestion with a number, so the size of digestion can be restrict in the number and the equality of  $x\cdot p==d$ is still hold after the modular operation. 

However, if we modular our digestion with an specific number $n$, some fake proofs can be constructed by selecting  $p \leftarrow d \cdot x^{-1} \mod n$. To deal with this problem, we move our digestion to power of a generator $g$ of an RSA Group, that is, we have $d = g^{\Pi_{s\in S}H(s)}$. In this way, the value of  $\Pi_{s\in S}H(s)$ will be automatically modulared by the order of the RSA Group, which is be promised to be unknown by trusted set-up.

Hash to Prime?

There are various ways to figure out how to efficiently  hash to prime. The code used a simple way by repeatedly hashing untill the ouput becomes prime.



## 02-MembershipProof

Since we have the digest $d = g^{\Pi_{s\in S}H(s)}$.

The Membership Proof of a message $m$ is $p = g^{\Pi_{s\in S/{\{m\}}}H(s)}$.

To verify the Membership Proof, we need to check $p^{H(m)} = g^{(\Pi_{s\in S/{\{m\}}}H(s))\cdot H(m)}=d$.



## 03-NonMembershipProof

First, for a message $m$ not in our digestion, we have $\gcd(H(m), \Pi_{s\in S}H(s)) = 1$,

Using the extended GCD, we can find $a, b$ satisfying $a\cdot H(m)+b\cdot(\Pi_{s\in S}H(s)) = 1$.

The NonMembership Proof of a message $m$ is $p = (g^a, b)$.

To verify the NonMembership Proof, we need to check
$$
\begin{align*} 
(g^a)^{H(m)}\cdot d^b &= g^{a\cdot H(m)}\cdot g^{b\cdot(\Pi_{s\in S}H(s))}
				   \\ &= g^{a\cdot H(m) + b\cdot(\Pi_{s\in S}H(s))}
				   \\ &= g
\end{align*}
$$





## Reference

1. Helger Lipmaa. Secure accumulators from euclidean rings without trusted setup. In Feng Bao, Pierangela Samarati, and Jianying Zhou, editors, ACNS 12, volume 7341 of LNCS, pages 224–240. Springer, Heidelberg, June 2012.

2. Boneh, D., Bünz, B., Fisch, B. (2019). Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains. In: Boldyreva, A., Micciancio, D. (eds) Advances in Cryptology – CRYPTO 2019. CRYPTO 2019. Lecture Notes in Computer Science(), vol 11692. Springer, Cham. https://doi.org/10.1007/978-3-030-26948-7_20

